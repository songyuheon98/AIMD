def main():
    import numpy as np
    import os
    from collections import Counter
    import tensorflow as tf
    from tensorflow.keras.preprocessing.image import ImageDataGenerator
    from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
    from tensorflow.keras.models import Sequential
    from sklearn.metrics import f1_score, precision_score, recall_score, accuracy_score
    from imblearn.over_sampling import SMOTE
    from tensorflow.keras.utils import to_categorical
    from sklearn.utils import shuffle
    from sklearn.metrics import classification_report
    from tensorflow.keras.metrics import Precision, Recall, Accuracy
    from tensorflow.keras import backend as K
    from tensorflow.keras.preprocessing import image
    import sys
    import time
    import threading
    from plyer import notification
    from pynput import mouse
    import winreg
    import random
    import shutil        
    import pefile
    import json
    import math
    from PIL import Image
    import psutil
    import tempfile
    from win10toast import ToastNotifier
    import csv
    import binascii
    import capstone
    import codecs
    from tensorflow.keras.applications.resnet import ResNet152
    from tensorflow.keras.layers import GlobalAveragePooling2D
    from tensorflow.keras.models import Model
    from tensorflow.keras.optimizers import Adam
    import matplotlib.pyplot as plt
    import pandas as pd
    from tensorflow.keras.applications import DenseNet121,DenseNet169,DenseNet201
    from tensorflow.keras import layers

    
    ## Code ==============================================================================

    # 파일 기본 경로 -------------------------------------------
    user_folder = os.path.expanduser("~")
    exe_save_dir = user_folder+"\AppData\Local\Malware_DT\\"    
    exe_Malware_DT = exe_save_dir+'Malware_DT.exe'
    # ----------------------------------------------------

    
    def get_model_path(model_file):
        if hasattr(sys, '_MEIPASS'):
            return os.path.join(sys._MEIPASS, model_file)
        else:
            return os.path.join(os.path.abspath("."), model_file)


    def predict_image(model, image_path):
        img = image.load_img(image_path, target_size=(299, 299), color_mode='rgb')

        
        # Convert to array and rescale
        img_array = image.img_to_array(img) / 255.
        img_array = np.expand_dims(img_array, axis=0)
        # Predict with the model
        predictions = model.predict(img_array)
        predicted_class = (predictions > 0.5).astype(int)
        print('100%')
        print(f"The predicted class is: {predicted_class[0][0]}")
        return predicted_class[0][0]


    def get_download_path():
        # 크롬 설정 파일 경로
        pref_path = os.path.join(os.environ["LOCALAPPDATA"], r"Google\Chrome\User Data\Default\Preferences")

        # 크롬 설정 파일을 읽어옴
        with open(pref_path, "r", encoding="utf-8") as f:
            pref_data = json.load(f)

        # 다운로드 폴더의 경로를 반환
        download_path = pref_data.get("download", {}).get("default_directory")
        if not download_path:
            download_path = os.path.join(os.path.expanduser("~"), "Downloads")
        if not os.path.exists(download_path):
            os.makedirs(download_path)
        return download_path

    
    def program_start():
        data_exe_dir = get_download_path() + '\\'
        # path\
        
        save_bytes_dir=exe_save_dir+'bytes_file\\'
        save_image_dir=exe_save_dir+'image_file\\'
        
        os.makedirs(save_bytes_dir, exist_ok=True)
        os.makedirs(save_image_dir, exist_ok=True)
        
        monitor_directory(data_exe_dir,save_bytes_dir,save_image_dir)
        # chrome 다운로드 파일 위치 확인 및 다운로드 파일 이미지화 저장

        
    def convert_image(data_dir, save_image_dir):
        # 전처리 ====================================================
        with open(data_dir + 'Download_file.bytes', "rb") as f1,\
             open(data_dir + 'Download_file2.bytes', "wb") as f2:
            for line in f1:
                f2.write(line[11:])
        with open(data_dir + "Download_file2.bytes", "rb") as f:
            bytes_data = f.read()

        test_data = bytes_data.replace(b' \n', b' ')
        test_data = test_data.replace(b'\n', b' ')
        test_data = test_data.replace(b'\r', b' ')
        test_data = test_data.replace(b'  ', b' ')

        str_test_data = str(test_data)[2:-1]
        str_test_data = str_test_data.replace('??', '00')
        str_test_split_data = str_test_data.split(" ")


        # ==============================================================
            
        # 이미지화 =====================================================     
        
        try:
            if len(str_test_split_data) % 2 == 1:
                str_test_split_data = str_test_split_data[:-1]

            coord = np.zeros((len(str_test_split_data)//2, 2))
            raw = 0
    
            for coo in str_test_split_data:
                if (raw % 2 == 0):
                    coord[raw // 2][0] = int(coo, 16)
                else:
                    coord[raw // 2][1] = int(coo, 16)
                raw = raw + 1

            vw_3d = np.zeros((256, 256))


            for coo2 in coord:
                vw_3d[int(coo2[0]), int(coo2[1])] = vw_3d[int(coo2[0]), int(coo2[1])] + 1

            vw_3d_div_max = np.zeros((256, 256))
            vw_3d_imsi = vw_3d.flatten()

            vw_3d_mean = 20

            for i in range(256):
                for j in range(256):
                    vw_3d_div_max[i][j] = (vw_3d[i][j] / vw_3d_mean) * 255
                    if(vw_3d_div_max[i][j] > 255):
                        vw_3d_div_max[i][j] = 255

            vw_3d_data = vw_3d_div_max.astype(int)

            img = Image.fromarray(vw_3d_data)
            gray_img = img.convert('L')
            gray_img.save(save_image_dir + f"Download_image_file.png", 'PNG')
                          
        except ValueError:
            print('valueError')
        print('75%')
        # ==========================================================================================                                    
                          
    def create_opcode(file_name,exe_file_path,bytes_file_path):
       
        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
        md.skipdata = True
            
        try:
            # exe 파일 열기
            pe = pefile.PE(exe_file_path+file_name)
            print(exe_file_path+file_name)
        except pefile.PEFormatError as e:
            print('Exe 파일이 아닙니다.')
            return

        # 어셈블리 코드 생성
        asm_code = ''

        index32=0
        # 섹션 정보 출력
        for section in pe.sections:
            if('.reloc' in section.Name.decode().rstrip()):
                break      

            # 섹션 코드 읽어오기
            section_data = section.get_data()

            instructions = md.disasm(section_data,section.VirtualAddress)

            # 어셈블리 코드 생성
            for insn in instructions:
                # opcode 추출
                opcode = insn.bytes.hex()
                imsi_opcode=f'{opcode}'

                x=0
                for j in imsi_opcode:
                    if(index32==0):
                        asm_code += f'0x{insn.address:08x} '
                    asm_code += j
                    index32+=1
                    x+=1

                    if(x%2==0):
                        asm_code+=' '

                    if(index32==32):
                        asm_code+='\n'
                        index32=0
        # 어셈블리 코드 저장
        with codecs.open(f'{bytes_file_path}Download_file.bytes', 'w', encoding='utf8') as f5:
            f5.write(asm_code)

        print('50%')

    def is_download_running():
        for process in psutil.process_iter(['pid', 'name']):
            try:
                process_info = process.as_dict(attrs=['pid', 'name'])
                process_name = process_info['name'].lower()
                if 'download' in process_name or 'downloader' in process_name:
                    return True
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
                pass
        return False

    
    def notify(title, message):
        toaster = ToastNotifier()
        toaster.show_toast(title, message)

        
    def get_newest_file(directory):
        # 디렉토리 내의 파일 리스트 가져오기
        files = os.listdir(directory)

        # .crdownload 확장자를 가지는 파일 제외하기
        files = [f for f in files if not f.endswith('.crdownload')]

        # 최근 수정된 파일 가져오기
        newest_file = max(files, key=lambda f: os.path.getmtime(os.path.join(directory, f)))
        return newest_file            

    
    
    def monitor_directory(data_exe_dir, save_bytes_dir, save_image_dir):

        last_file = None
        files_len = len(os.listdir(data_exe_dir))
        check=0
        while True:
            new_files_len = len(os.listdir(data_exe_dir))
            if new_files_len > files_len:
                try:
                    notify('파일 다운로드 시작','~')
                    while True:
                        if not is_download_running():
                            notify("다운로드 완료", "파일이 성공적으로 다운로드되었습니다.")
                            new_file = get_newest_file(data_exe_dir)
                            print("25%")
                            create_opcode(new_file, data_exe_dir, save_bytes_dir)
                            # bytes 파일 생성
                            
                            convert_image(save_bytes_dir,  save_image_dir)
                            # 이미지 파일 생성
                            
                            
                            check = predict_image(model, save_image_dir + f"Download_image_file.png")
                            # 모델 체크 
                            
                            #================================
                            
                            if check ==0:
                                notify('Warnings','악성파일로 의심됩니다.')
                            else:
                                notify('safe','정상파일 입니다.')
                                
                            break
                            
                    files_len = new_files_len
                except pefile.PEFormatError:
                    print(f"{new_file} 파일은 PE 파일이 아닙니다.")
            time.sleep(1)

    model = Sequential()

    # First convolutional layer
    model.add(Conv2D(filters=6, kernel_size=(5, 5), strides=(1, 1), activation='tanh', input_shape=(299, 299, 3), padding='same'))

    # First pooling layer
    model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

    # Second convolutional layer
    model.add(Conv2D(filters=16, kernel_size=(5, 5), strides=(1, 1), activation='tanh', padding='valid'))

    # Second pooling layer
    model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

    # Fully connected layers
    model.add(Flatten())
    model.add(Dense(units=120, activation='tanh'))
    model.add(Dense(units=84, activation='tanh'))

    # Output layer
    model.add(Dense(units=1, activation='sigmoid'))

    model.compile(optimizer='RMSprop', loss='binary_crossentropy', metrics=[Precision()])

    model_path = get_model_path("model_weights15.h5")
    
    model.load_weights(model_path)
    
    
    # ------------ 동작을 위한 디렉터리 및 파일 복사
        # 디렉터리 존재 여부 확인
    if not os.path.isdir(exe_save_dir):
        # 디렉터리가 존재하지 않으면 생성
        os.makedirs(exe_save_dir, exist_ok=True)

    # 파일 존재 여부 확인)
    if not os.path.isfile(exe_Malware_DT):
        # 파일이 존재하지 않으면 생성
        #shutil.copyfile('./dist/Malware_DT.exe',exe_save_dir+'Malware_DT.exe' ) 
        
        shutil.copyfile('./Malware_DT.exe',exe_save_dir+'Malware_DT.exe' ) 

    
    # 시작 프로그램 등록 ======================
    # 시작 프로그램 등록을 위한 레지스트리 경로 설정
    key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"

    # 등록할 파일 경로 설정
    file_path = r''+exe_Malware_DT
    
    # 레지스트리 키 생성 및 파일 등록
    with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE) as key:
        winreg.SetValueEx(key, os.path.basename(file_path), 0, winreg.REG_SZ, file_path)


    notify('Malware_DT','Active') 
    program_start()
    
if __name__ == '__main__':
    main()
